#!/usr/bin/env python3

# Simple utility for programming SPI flash via a UART shell in the bootloader.
# The bootloader possesses a 1-page buffer which we can write to, read from and
# checksum.
# It also possesses commands for transfers between this buffer and the SPI flash,
# flash erasure, and launching the 2nd stage boot code.

import argparse
import os
import serial
import sys
from time import sleep

PAGESIZE = 256
SECTORSIZE = 4096

def progress(header, frac, width=40):
	n = int(width * frac)
	sys.stdout.write("\r" + header + "▕" + "▒" * n + " " * (width - n) + "▏")

# TODO: handle this gracefully!
# Go up as few levels as possible,
# do a shell reset sequence, fix any damage done
# to flash state (i.e. erase anything potentially
# programmed with wrong data), and keep going.
class ProtocolError(Exception):
	pass

class CMD:
	NOP          = '\n'.encode()
	WRITE_BUF    = 'w'.encode()
	READ_BUF     = 'r'.encode()
	GET_CHECKSUM = 'c'.encode()
	SET_ADDR     = 'a'.encode()
	WRITE_FLASH  = 'W'.encode()
	READ_FLASH   = 'R'.encode()
	ERASE_SECTOR = 'E'.encode()
	BOOT_2ND     = 'B'.encode()
	ACK          = ':'.encode()

def reset_shell(port):
	while True:
		port.write(CMD.NOP * (PAGESIZE + 1))
		port.flushOutput()
		sleep(0.02)
		port.flushInput()
		port.write(CMD.NOP)
		sleep(0.02)
		if port.readable() and port.read_all().endswith(CMD.ACK):
			break

def check_ack(port):
	resp = port.read()
	if len(resp) == 0 or resp != CMD.ACK:
		raise ProtocolError()

def write_buf(port, data):
	assert(len(data) == 256)
	port.write(CMD.WRITE_BUF)
	port.write(data)
	check_ack(port)
	# TODO checksum

def read_buf(port):
	port.write(CMD.READ_BUF)
	resp = port.read(PAGESIZE)
	if len(resp) != PAGESIZE:
		raise ProtocolError()
	return resp
	# TODO checksum

def set_addr(port, addr):
	addr_b = bytes([
		(addr >> 16) & 0xff,
		(addr >>  8) & 0xff,
		(addr >>  0) & 0xff
	])
	port.write(CMD.SET_ADDR + addr_b)
	echo = port.read(3)
	if echo != addr_b:
		raise ProtocolError()
	check_ack(port)

def read_flash(port, addr, size):
	set_addr(port, addr)
	data = bytes()
	for _ in range(addr, addr + size, PAGESIZE):
		progress("Read:  ", (_ - addr) / size)
		port.write(CMD.READ_FLASH)
		check_ack(port)
		data += read_buf(port)
	progress("Read:  ", 1)
	print()
	if len(data) > size:
		data = data[:size] # ouch
	return data

def write_flash(port, addr, data):
	assert(addr % PAGESIZE == 0)
	if len(data) % PAGESIZE != 0:
		data += bytes(PAGESIZE - len(data) % PAGESIZE)
	set_addr(port, addr)
	for i in range(len(data) // PAGESIZE):
		progress("Write: ", i / (len(data) // PAGESIZE))
		write_buf(port, data[i * PAGESIZE : (i + 1) * PAGESIZE])
		port.write(CMD.WRITE_FLASH)
		check_ack(port)
	progress("Write: ", 1)
	print("")

def erase_flash(port, addr, size):
	end = addr + size
	start = addr - addr % SECTORSIZE
	set_addr(port, start)
	for _ in range(start, end, SECTORSIZE):
		progress("Erase: ", (_ - start) / (end - start))
		port.write(CMD.ERASE_SECTOR)
		check_ack(port)
	progress("Erase: ", 1)
	print("")

def any_int(x):
	return int(x, 0)

if __name__ == "__main__":
	parser = argparse.ArgumentParser()
	parser.add_argument("file", nargs="?", help="Filename to read from or dump to.")
	parser.add_argument("--uart", "-u", help="Path to UART device (e.g. /dev/ttyUSB0)")
	parser.add_argument("--write", "-w", action="store_true",
		help="Write to flash (default is read)")
	parser.add_argument("--verify", "-v", action="store_true",
		help="Verify contents after programming (use with --write)")
	parser.add_argument("--start", "-s", type=any_int, help="Base address to start read/write")
	parser.add_argument("--len", "-l", type=any_int, help="Number of bytes to read, or override file length for write.")
	args = parser.parse_args()

	# Do some simple parameter checking to make it harder to accidentally trash your device
	if args.write and args.file is None:
		sys.exit("Must specify filename for write")
	if args.start is None:
		args.start = 0
	if args.uart is None:
		args.uart = "/dev/ttyUSB0"
	if args.verify and not args.write:
		sys.exit("Verify is only valid for a write operation")
	if args.write and (args.start % PAGESIZE != 0):
		sys.exit("Writes must be aligned on a {}-byte boundary.".format(PAGESIZE))
	if args.write:
		try:
			filesize = os.stat(args.file).st_size
			if args.len is None:
				args.len = filesize
		except:
			sys.exit("Could not open file '{}'".format(args.file))
	else:
		if args.len is None:
			args.len = PAGESIZE

	# Don't want to overwrite their image if they forget -w
	if not args.write and args.file and os.path.exists(args.file):
		resp = ""
		while not resp in ["y", "n"]:
			resp = input("File '{}' exists. Overwrite? (y/n) ".format(args.file))
			resp = resp.lower().strip()
		if resp == "n":
			sys.exit(0)

	# Summarise what we're about to do
	print("{} {} bytes {} {}, starting at address 0x{:06x}".format(
		"Writing" + (" and verifying" if args.verify else "") if args.write else "Reading",
		args.len,
		"from" if args.write else "to",
		"stdout" if args.file is None else "file " + args.file,
		args.start,
		", and verifying" if args.verify else ""
	))

	# And then do it
	# need to allow for page erase, upward of 60 ms.
	port = serial.Serial(args.uart, 500000, timeout=1)
	print("Waiting for bootloader...")
	reset_shell(port)
	print("")

	if args.write:
		data = open(args.file, "rb").read()
		if len(data) > args.len:
			data = data[:args.len]
		else:
			data = data + bytes(args.len - len(data)) # zero padding
		erase_flash(port, args.start, args.len)
		print("")
		write_flash(port, args.start, data)
		print("")
		if (args.verify):
			readback = read_flash(port, args.start, args.len)
			print("")
			if readback != data:
				sys.exit("Verification failed.") # TODO: better info
		print("Done")
	else:
		data = read_flash(port, args.start, args.len)
		print("\nDone")
		if args.file:
			open(args.file, "wb").write(data)
		else:
			for i, byte in enumerate(data):
				if i % 8 == 0:
					sys.stdout.write("{:06x}: ".format(args.start + i))
				sys.stdout.write("{:02x}".format(byte))
				sys.stdout.write("\n" if i % 8 == 7 else " ")
			sys.stdout.write("\n")