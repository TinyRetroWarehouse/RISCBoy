#!/usr/bin/env python3

# Regblock generation script

import sys
from collections import OrderedDict
import yaml

def width2str(w):
	return "[{}:0]".format(w - 1)

class Verilog:
	def __init__(self):
		self.header = []
		self.ports = []
		self.decls = []
		self.logic_comb = []
		self.logic_rst = []
		self.logic_clk = []
	def __add__(self, other):
		new = Verilog()
		new.header.extend(self.header)
		for n, s, o in zip(
			[new.ports, new.decls, new.logic_comb, new.logic_rst, new.logic_clk],
			[self.ports, self.decls, self.logic_comb, self.logic_rst, self.logic_clk],
			[other.ports, other.decls, other.logic_comb, other.logic_rst, other.logic_clk]):
			n.extend(s)
			n.extend(o)
		return new
	def __str__(self):
		strs = []
		strs.extend(self.header)
		strs.extend("\t" + s + ("" if s == "" or s.startswith("//") else ",")  for s in self.ports[:-1])
		if len(self.ports) > 0:
			strs.append("\t" + self.ports[-1])
		strs.append(");")
		strs.append("")
		strs.extend(self.decls);
		strs.append("")
		strs.append("always @ (*) begin")
		strs.extend("\t" + s for s in self.logic_comb)
		strs.append("end")
		strs.append("")
		strs.append("always @ (posedge clk or negedge rst_n) begin")
		strs.append("\tif (!rst_n) begin")
		strs.extend("\t\t" + s for s in self.logic_rst)
		strs.append("\tend else begin")
		strs.extend("\t\t" + s for s in self.logic_clk)
		strs.append("\tend")
		strs.append("end")
		strs.append("")
		strs.append("endmodule\n")
		return "\n".join(strs)

class RegBlock:
	bus_types = ["apb"]
	def __init__(self, name, w_data, w_addr, bus):
		self.name = name
		self.w_data = w_data
		self.w_addr = w_addr
		if bus not in self.bus_types:
			raise Exception("Unknown bus type: {}".format(bus))
		self.bus = bus
		self.regs = []
	def add(self, reg):
		self.regs.append(reg)
	@staticmethod
	def load(fname):
		y = yaml.load(open(fname).read())
		if "bus" not in y:
			sys.exit("Must specify bus type with \"bus: x\"")
		if "data" not in y:
			sys.exit("Must specify data width with \"data: x\"")
		if "addr" not in y:
			sys.exit("Must specify address width with \"addr: x\"")
		if "name" not in y:
			sys.exit("Must specify regblock name with \"name: x\"")
		rb = RegBlock(y["name"], y["data"], y["addr"], y["bus"])
		for rspec in y["regs"]:
			reg = Register(rspec["name"], rb.w_data, rspec["info"] if "info" in rspec else None)
			rb.add(reg)
			for fspec in rspec["bits"]:
				bitrange = fspec["b"]
				if type(bitrange) is int:
					bitrange = [bitrange, bitrange]
				reg.add(Field(
					fspec["name"] if "name" in fspec else "",
					bitrange[0],
					bitrange[1],
					fspec["access"],
					fspec["rst"] if "rst" in fspec else 0,
					fspec["info"] if "info" in fspec else None
				))
		return rb
	def to_verilog(self):
		v = Verilog()
		v.header.extend(["// Autogenerated with regblock", "// Do not edit manually", ""])
		v.header.append("module {}_regs (".format(self.name))
		v.ports.extend(["input wire clk", "input wire rst_n",])
		if self.bus == "apb":
			v.ports.append("")
			v.ports.append("// APB Port")
			v.ports.append("input wire psel")
			v.ports.append("input wire penable")
			v.ports.append("input wire pwrite")
			v.ports.append("input wire {} apbs_paddr".format(width2str(self.w_addr)))
			v.ports.append("input wire {} apbs_pwdata".format(width2str(self.w_data)))
			v.ports.append("output wire {} apbs_prdata".format(width2str(self.w_data)))
			v.ports.append("output wire apbs_pready")
			v.ports.append("output wire apbs_pslverr")
			v.decls.append("// APB adapter")
			v.decls.append("wire {} wdata = apbs_pwdata;".format(width2str(self.w_data)))
			v.decls.append("reg {} rdata;".format(width2str(self.w_data)))
			v.decls.append("wire wen = apbs_psel && apbs_penable && apbs_pwrite;")
			v.decls.append("wire ren = apbs_psel && apbs_penable && !apbs_pwrite;")
			v.decls.append("wire {} addr = apbs_paddr;".format(width2str(self.w_addr)))
			v.decls.append("assign apbs_prdata = rdata;")
			v.decls.append("assign apbs_pready = 1'b1;")
			v.decls.append("assign apbs_pslverr = 1'b0;")
			v.decls.append("")
		v.ports.append("")
		v.ports.append("// Register interfaces")
		for i, reg in enumerate(self.regs):

			v.decls.append("localparam ADDR_{} = {};".format(reg.name.upper(), i * 4))
		for reg in self.regs:
			v.decls.append("wire {}_wen = wen && addr == ADDR_{};".format(reg.name, reg.name.upper()))
			v.decls.append("wire {}_ren = ren && addr == ADDR_{};".format(reg.name, reg.name.upper()))
		v.logic_comb.append("case (addr)")
		for reg in self.regs:
			v.logic_comb.append("\tADDR_{}: rdata = {}_rdata;".format(reg.name.upper(), reg.name))
		v.logic_comb.append("\tdefault: rdata = {}'h0;".format(self.w_data))
		v.logic_comb.append("endcase")
		for reg in self.regs:
			v = v + reg.to_verilog()
		return v

class Register:
	def __init__(self, name, width, info):
		assert(width > 0)
		self.name = name
		self.width = width
		self.info = info
		self.occupancy = [None] * width
		self.fields = OrderedDict()
	def add(self, field):
		if field.lsb >= self.width or field.msb >= self.width or field.lsb < 0 or field.msb < 0:
			raise Exception("Field {} extends outside of register {}".format(field.name, self.name))
		if field.name in self.fields:
			raise Exception("{} already has a field called \"{}\"".format(self.name, field.name))
		for i in range(field.lsb, field.msb + 1):
			if self.occupancy[i] is not None:
				raise Exception("Field {} overlaps {} in register {}".format(field.name, occupancy[i], self.name))
			self.occupancy[i] = field.name
		self.fields[field.name] = field
	def to_verilog(self):
		v = Verilog()
		v.decls.append("")
		for field in self.fields.values():
			v = v + field.to_verilog(self.name)
		rdata_conns = []
		empty_count = 0
		last_occupant = None
		for occupant in reversed(self.occupancy):
			if occupant is None:
				empty_count += 1
			elif occupant != last_occupant:
				if empty_count > 0:
					rdata_conns.append("{}'h0".format(empty_count))
					empty_count = 0
				rdata_conns.append("{}_{}_rdata".format(self.name, occupant))
			last_occupant = occupant
		if empty_count > 0:
			rdata_conns.append("{}'h0".format(empty_count))
		v.decls.append("wire {} {}_rdata = {{{}}};".format(width2str(self.width), self.name, ", ".join(rdata_conns)))
		for field in self.fields.values():
			lsb = self.occupancy.index(field.name)
			msb = lsb - 1 + self.occupancy.count(field.name)
			v.decls.append("assign {}_{}_wdata = wdata[{}:{}];".format(self.name, field.name, msb, lsb))
		return v


class Field:
	access_types = ["ro", "rov", "rw", "rf", "wf", "rwf"]
	def __init__(self, name, msb, lsb, access, resetval=0, info=""):
		if lsb > msb:
			raise Exception("Field width must be >= 0 in field {}".format(name))
		if access not in self.access_types:
			raise Exception("Unknown access type: {}. Recognised types: {}".format(access, ", ".join(access_types)))
		self.name = name
		self.msb = msb
		self.lsb = lsb
		self.access = access
		self.info = info

	@property
	def width_decl(self):
		if self.msb == self.lsb:
			return ""
		else:
			return "[{}:0]".format(self.msb - self.lsb)

	def to_verilog(self, regname):
		v = Verilog()
		name = "{}_{}".format(regname, self.name)
		v.decls.append("wire {} {}_rdata;".format(self.width_decl, name))
		v.decls.append("wire {} {}_wdata;".format(self.width_decl, name))
		if self.access in ["rov", "rf", "rwf"]:
			v.ports.append("input wire {} {}_i".format(self.width_decl, name))
			v.decls.append("assign {}_rdata = {}_i;".format(name, name))
		if self.access in ["rw", "wf", "rwf"]:
			v.ports.append("output reg {} {}_o".format(self.width_decl, name))
		if self.access in ["wf", "rwf"]:
			v.ports.append("output reg {}_wen".format(name))
			v.logic_comb.append("{}_wen = {}_wen;".format(name, regname))
			v.logic_comb.append("{}_o = {}_wdata;".format(name, name))
		if self.access in ["rf", "rwf"]:
			v.ports.append("output reg {}_ren".format(name))
			v.logic_comb.append("{}_ren = {}_ren;".format(name, regname))
		if self.access in ["rw"]:
			v.decls.append("assign {}_rdata = {}_o;".format(name, name))
			v.logic_rst.append("{}_o <= {}'h0;".format(name, self.msb - self.lsb + 1))
			v.logic_clk.append("if ({}_wen)".format(regname))
			v.logic_clk.append("\t{}_o <= {}_wdata;".format(name, name))
		return v
		
def main(argv):
	rb = RegBlock.load(argv[1])
	print(str(rb.to_verilog()))

if __name__ == "__main__":
	main(sys.argv)